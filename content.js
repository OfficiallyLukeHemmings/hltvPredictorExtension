async function createAndRenderPrediction() {
  /* Creating and displaying a prediction box on the page. Predictions are 
  fetched from an API hosting two ML prediction models. */

  async function postRequest(gameDetails) {
    /* Handling the post request to the ML API. 
    Returns: JSON object of the two predictions generated by the API.
    
    JSON Structure = { 
        "optimistic-prediction": 0/1,
        "pessimistic-prediction": 0/1 
    } */

    // Handling POST request to API
    let predictions = await fetch("https://hltv-prediction-extension-api.ew.r.appspot.com/", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(gameDetails)
    }).then(res => {
      // If status is anything but 200, throw error and preventing rendering
      // of Prediction Box on page. 
      if (res.status !== 200) {
        throw new Error("Invalid response status from POST request");
      }
      // Returning of JSON object to fetch.then() function 
      // i.e. predictions = res.json()
      return res.json();
    });

    // Return JSON of predictions (see JSON Structure above) recevied from 
    // the ML API.
    return predictions;
  }


  async function generatePredictionString(predictions) {
    /* Generating the prediction string to be displayed in the prediction
    box based on the inspected game's enjoyability predictions.
    Prediction string describes each ML model's enjoyability prediction
    Returns: String */

    // Predictions will be either 1 (truthy) or 0 (falsy), hence the use of 
    // ternary operators to condense the const assignment.
    const optimisticPrediction = predictions["optimistic-prediction"]
      ? "ðŸ˜Ž\n You will likely enjoy this game"
      : "ðŸ˜´\n You likely won't enjoy this game";

    const pessimisticPrediction = predictions["pessimistic-prediction"]
      ? "ðŸ˜Ž\n You will likely enjoy this game"
      : "ðŸ˜´\n You likely won't enjoy this game";

    // Formatting of PredictionBox text
    let predictionText = `Optimistic Prediction: ${optimisticPrediction}

    Pessimistic Prediction: ${pessimisticPrediction}`; 

    /* In the testing phase test users highlighted the pessimistic predictions
     to be more accurace in a working environment. As such, this extension
     was adapted to provide only the pessimistic predictions. 
     The code above remains unchanged to allow markers to see the code's 
     state during the testing phase. Below the prediction text is replaced
     by the pessimistic prediction only.
    */ 

    // Replacing the predictionText with the pessimistic prediction only.
    predictionText = pessimisticPrediction;
    // Returns string to be displayed in prediction box created 
    return predictionText;
  }


  function createPredictionBox(predictionString) {
    /* Creating a new prediction box based on similar elements present on the 
    match page containing the prediction string generated. */

    // Getting correct div for addition of prediction detail to page
    const div = document.querySelector("body > div.bgPadding > div.widthControl > div.colCon > div.contentCol > div.match-page > div.g-grid.maps > div.col-6.col-7-small");
    
    // Creation of span subtitle
    const span = document.createElement("span");
    span.classList.add("headline");
    span.innerHTML = "HLTV Extension Prediction";

    // Creation of prediction box (nested div)
    const predictionOuterBox = document.createElement("div");
    predictionOuterBox.classList.add("prediction-box", "standard-box", "veto-box");
    // (changing element style to be easily identifiable by users)
    predictionOuterBox.style.color = "#ffffff";
    predictionOuterBox.style.backgroundColor = "#435971";
    predictionOuterBox.style.fontWeight = "bold";
    predictionOuterBox.style.fontSize = "16px";

    const predictionInnerBox = document.createElement("div");
    predictionInnerBox.classList.add("padding", "preformatted-text");
    predictionInnerBox.innerText = predictionString;
    predictionOuterBox.appendChild(predictionInnerBox);

    // Appending span sub-title and prediction box to page
    div.prepend(predictionOuterBox);
    div.prepend(span);
  }


  // If game is upcoming or ongoing...
  if (getIsGameIncomplete()) {
    // Ensuring the DOM is loaded before seeking the game details required for
    // generating predictions
    window.addEventListener("load", async (e) => {
      try {
        // Get game features from upcoming/ongoing game
        const gameDetails = getGameDetails();
        
        // If any of the game details required for generating predictions are
        // missing then throw an error.
        // missingDetail = Boolean, indicating whether details are missing
        const missingDetail = Object.values(gameDetails).some(
          (detail) => detail === null);

        if (missingDetail) throw new Error("Game detail missing");
        
        // Sending a POST request given the inspected game's details
        predictions = await postRequest(gameDetails);

        // Generating a prediction string to be displayed inside the prediction 
        // box given a pair of predictions requested from the ML API.
        predictionString = await generatePredictionString(predictions);
        
        // Given the predictionString generated from the predictions, create a
        // new prediction box element to display the ML predictions clearly
        // to users
        createPredictionBox(predictionString);
  
      } catch (err) {
        console.log(err.message);
      }
    });
  } else {
    console.log("Upcoming or live game not found");
  }
}


function getIsGameIncomplete(){
  /* Getting whether or not inspected game is incomplete, i.e. upcoming or 
  ongoing. 
  Returns: Boolean */
  
  // Initialising countdown to null.
  let countdown = null;

  try {
    // Try getting countdown innertext for an upcoming game
      countdown = document.querySelector(
        "body > div.bgPadding > div.widthControl > div.colCon > div.contentCol > div.match-page > div.standard-box.teamsBox > div.timeAndEvent > div.countdown"
      ).innerText;
  } catch (err) {
    console.log(err.message);
    try {
      // Try for a LIVE game instead (if countdown not found already)
      if (countdown == null) {
        countdown = document.querySelector("body > div.bgPadding > div.widthControl > div.colCon > div.contentCol > div.match-page > div.standard-box.teamsBox > div.timeAndEvent > div.countdown.countdown-live").innerText;  
      }
    } catch (err) {
      console.log(err.message);
    }
  }

  try {
    // Returning boolean indicating if game is incomplete
    // (Returns true if game is incomplete)
    return (countdown.toLowerCase() !== "match over");
  } catch (err) {
    console.log(err.message);
    // Returns false if game is *not* incomplete, i.e. if game is over
    return false
  }
}


function getGameType() {
  /* Getting the game type (LAN, Online, or Major game) and returning the 
  corresponding value associated for each game type.
  Return value: Int, (0 = Online; 1 = LAN; 2 = Major) */
  
  // Getting event title to check whether game is part of a Major event
  const eventTitle = document.querySelector("body > div.bgPadding > div.widthControl > div.colCon > div.contentCol > div.match-page > div.standard-box.teamsBox > div.timeAndEvent > div.event.text-ellipsis > a");
  // If event is a Major event - "major" will be included in the event
  // title if so...
  if (eventTitle.innerText.toLowerCase().includes("major")) {
    return 2; // 2 = Major event
  } else {
    // If not a Major event the game type can be elicited from the info box 
    // Getting info box text to check for presence of game type keyword
    const infoBoxText = document.querySelector("body > div.bgPadding > div.widthControl > div.colCon > div.contentCol > div.match-page > div.g-grid.maps > div.col-6.col-7-small > div.standard-box.veto-box > div")
      .innerText
      .toLowerCase();

    // (Below) Brackets surround game type in if statement incase the notes
    // section of the info box contains a game type keyword in an upcoming
    // event's title (e.g. OnlineExtreme Spring Showdown, where "Online" is
    // present but only as part of an event title, and not indicating the
    // inspected game's type).
    if (infoBoxText.includes("(lan)")) {
      return 1; // 1 = 'LAN' event
    } else if (infoBoxText.includes("(online)")) {
      return 0; // 0 = 'Online' event
    } else {
      console.log("Game type not found");
    }
  }
}


function getBettingDiff() {
  /* Getting the mean betting odds difference from the betting odds table on 
  the HLTV match page. Returns the mean betting odds difference as a float. */

  // Getting betting odds table
  const bettingTable = document.querySelector("#betting > div.g-grid > div.col-8.mobile-normal-priority > div.match-betting-list.standard-box > table > tbody");
  // Storing table rows from betting table in an array
  const rowsArray = Array.from(bettingTable.rows);
  // Removing title row
  rowsArray.shift();

  // Calculating betting odds for each valid row (as table rows infrequently
  // display a promotional message instead of the betting odds for the game)
  // Storing the count of valid rows (i.e. rows containing a betting provider's
  // betting odds) for calculating a mean difference.
  let bettingDifferencesSums = 0;
  let validBettingRows = 0;

  rowsArray.forEach((row) => {
    try {
      // Getting the betting odds for each team
      const leftVal = row.children[1].innerText;
      const rightVal = row.children[3].innerText;
      
      // If both betting odds values are found...
      if (leftVal && rightVal) {
        // Calculating the Absolute difference (non-negative value)
        // in betting odds
        const bettingDifference = Math.abs(
          parseFloat(leftVal) - parseFloat(rightVal)
        );

        // If betting odds difference can be calculated, i.e. if a valid 
        // row... (I.e. if bettingDifference != NaN)
        if (bettingDifference) {
          // Increasing count of valid betting rows
          validBettingRows++;
          // Cumulative betting odds difference
          bettingDifferencesSums += bettingDifference;
        }
      }
    } catch (error) {
      console.log("Error while reading betting rows -", error);
    }
  });

  // Throw an error if no valid betting odds rows are found, i.e. if all 
  // betting odds rows contain promotions rather than the betting odds
  if (validBettingRows === 0) throw new Error("No readable betting rows found");
  
  // Return the mean betting difference (absolute value) to 3dp.
  return parseFloat((bettingDifferencesSums / validBettingRows).toFixed(3));
}


function getTeamRanks() {
  /* Getting each team's world ranking and returning them in a JSON object. */

  // Creating the JSON object to be returned
  const teamRanks = {
    team1Rank: null,
    team2Rank: null,
  };

  // Getting both team's world ranking divs from the page
  rankingDivs = document.getElementsByClassName("teamRanking");

  // Getting each team's world ranking 
  teamRanks.team1Rank = parseInt(
    rankingDivs[0].firstElementChild.lastChild.data.substring(1)
  );
  teamRanks.team2Rank = parseInt(
    rankingDivs[1].firstElementChild.lastChild.data.substring(1)
  );

  // Return world rankings as a JSON object
  return teamRanks;
}


function getGameDetails() {
  /* Getting all game detials required for enjoyability predictions and
  then returning these details as a JSON object. */

  // Creating gameDetails JSON object to be later sent to ML API
  const gameDetails = {
    "eventType": null,
    "team1Rank": null,
    "team2Rank": null,
    "bettingOddsDiff": null,
  };

  // Getting event type
  gameDetails.eventType = getGameType();
  // Getting betting odds difference
  gameDetails.bettingOddsDiff = getBettingDiff();
  // Getting team ranks
  const teamRanks = getTeamRanks();
  gameDetails.team1Rank = teamRanks.team1Rank;
  gameDetails.team2Rank = teamRanks.team2Rank;

  // Return game details JSON object
  return gameDetails;
}


// Control Flow entry point
createAndRenderPrediction();